/* Start Header =========================================================================
File Name:		Matrix33.cpp
Purpose:		Implements a 3x3 Matrix.
Language:		C++, Visual Studio 2013 compiler
Author:			Hew Jun-Wei
== End Header =========================================================================*/

// Includes:
//---------------------------------------------------------------------------------------
#include "Matrix.h"
#include <cmath>		// cosf(), sinf()


// Constructors/Destructors:
//---------------------------------------------------------------------------------------
Matrix33::Matrix33() : a1(1.0f, 0.0f, 0.0f), a2(0.0f, 1.0f, 0.0f), a3(0.0f, 0.0f, 1.0f) {};
Matrix33::~Matrix33() {}
Matrix33::Matrix33( float m00, float m01, float m02,
					float m10, float m11, float m12,
					float m20, float m21, float m22) : 
a1(m00, m01, m02), a2(m10, m11, m12), a3(m20, m21, m22) {}


/***************************************************************************************/
/***************************************************************************************/
Matrix33::Matrix33(Vector3 a1, Vector3 a2, Vector3 a3) : a1(a1), a2(a2), a3(a3) {}


/***************************************************************************************/
/***************************************************************************************/
Matrix33::Matrix33(const Matrix33& rhs)
{
	(*this) = rhs;
}

// Member accessors:
//---------------------------------------------------------------------------------------

/***************************************************************************************/
/***************************************************************************************/
float& Matrix33::operator[](unsigned index)
{
	return data[index];
}


/***************************************************************************************/
/***************************************************************************************/
float Matrix33::operator[](unsigned index) const
{
	return data[index];
}


/***************************************************************************************/
/***************************************************************************************/
float& Matrix33::ColRow(unsigned column, unsigned row)
{
	return data[(3 * column) + row];
}


/***************************************************************************************/
/***************************************************************************************/
float Matrix33::ColRow(unsigned column, unsigned row) const
{
	return data[(3 * column) + row];
}


/***************************************************************************************/
/***************************************************************************************/
float& Matrix33::operator()(unsigned column, unsigned row)
{
	return data[(3 * column) + row];
}


/***************************************************************************************/
/***************************************************************************************/
float Matrix33::operator()(unsigned column, unsigned row) const
{
	return data[(3 * column) + row];
}


// Member operations:
//---------------------------------------------------------------------------------------

/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::Transpose() const
{
	return Matrix33(data[0], data[3], data[6],
					data[1], data[4], data[7],
					data[2], data[5], data[8]);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33& Matrix33::TransposeThis()
{
	(*this) = this->Transpose();

	return (*this);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::Inverse() const
{
	// cofactor matrix
	Matrix33 result( (m11 * m22) - (m12 * m21), (m10 * m22) - (m20 * m12), (m10 * m21) - (m11 * m20),
					 (m01 * m22) - (m21 * m02), (m00 * m22) - (m02 * m20), (m00 * m21) - (m20 * m01),
					 (m01 * m12) - (m11 * m02), (m00 * m12) - (m10 * m02), (m00 * m11) - (m10 * m01) );

	for(int i = 1; i < 8; i += 2)
		result.data[i] *= -1;

	result.TransposeThis();

	return result/Determinant();
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33& Matrix33::InverseThis()
{
	(*this) = this->Inverse();

	return (*this);
}


/***************************************************************************************/
/***************************************************************************************/
float Matrix33::Determinant() const
{
	return (m00 * ((m11 * m22) - (m12 * m21))) - 
		   (m10 * ((m01 * m22) - (m02 * m21))) +
		   (m20 * ((m01 * m12) - (m02 * m11)));
}

// Matrix operations:
//---------------------------------------------------------------------------------------

/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::operator+(const Matrix33& rhs) const
{
	return Matrix33(a1 + rhs.a1, a2 + rhs.a2, a3 + rhs.a3);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::operator-(const Matrix33& rhs) const
{
	return Matrix33(a1 - rhs.a1, a2 - rhs.a2, a3 - rhs.a3);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33& Matrix33::operator+=(const Matrix33& rhs)
{
	for(int i = 0; i < 9; ++i)
		data[i] += rhs.data[i];

	return (*this);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33& Matrix33::operator-=(const Matrix33& rhs)
{
	for(int i = 0; i < 9; ++i)
		data[i] -= rhs.data[i];

	return (*this);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::operator*(const Matrix33& rhs) const
{
	return Matrix33( (m00 * rhs.m00) + (m10 * rhs.m01) + (m20 * rhs.m02),
					 (m01 * rhs.m00) + (m11 * rhs.m01) + (m21 * rhs.m02),
					 (m02 * rhs.m00) + (m12 * rhs.m01) + (m22 * rhs.m02),

					 (m00 * rhs.m10) + (m10 * rhs.m11) + (m20 * rhs.m12),
					 (m01 * rhs.m10) + (m11 * rhs.m11) + (m21 * rhs.m12),
					 (m02 * rhs.m10) + (m12 * rhs.m11) + (m22 * rhs.m12),

					 (m00 * rhs.m20) + (m10 * rhs.m21) + (m20 * rhs.m22),
					 (m01 * rhs.m20) + (m11 * rhs.m21) + (m21 * rhs.m22),
					 (m02 * rhs.m20) + (m12 * rhs.m21) + (m22 * rhs.m22) );
}


// Vector operations:
//---------------------------------------------------------------------------------------

/***************************************************************************************/
/***************************************************************************************/
Vector3 Matrix33::operator*(const Vector3& rhs) const
{
	return Vector3( (data[0] * rhs.x) + (data[3] * rhs.y) + (data[6] * rhs.z),
					(data[1] * rhs.x) + (data[4] * rhs.y) + (data[7] * rhs.z),
					(data[2] * rhs.x) + (data[5] * rhs.y) + (data[8] * rhs.z) );
}


// Scalar operations:
//---------------------------------------------------------------------------------------

/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::operator*(const float rhs) const
{
	Matrix33 result = (*this);

	for(int i = 0; i < 9; ++i)
		result.data[i] *= rhs;

	return result;
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 operator*(float lhs, const Matrix33& rhs)
{
	return rhs * lhs;
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::operator/(const float rhs) const
{
	Matrix33 result = (*this);

	for(int i = 0; i < 9; ++i)
		result.data[i] /= rhs;

	return result;
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33& Matrix33::operator*=(const float rhs)
{
	for(int i = 0; i < 9; ++i)
		data[i] *= rhs;

	return (*this);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33& Matrix33::operator/=(const float rhs)
{
	for(int i = 0; i < 9; ++i)
		data[i] /= rhs;

	return (*this);
}


// The following functions construct a matrix:
//---------------------------------------------------------------------------------------

/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::Zero()
{
	return Matrix33(0.0f, 0.0f, 0.0f,
					0.0f, 0.0f, 0.0f,
					0.0f, 0.0f, 0.0f);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::Identity()
{
	return Matrix33(1.0f, 0.0f, 0.0f,
					0.0f, 1.0f, 0.0f,
					0.0f, 0.0f, 1.0f);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::Scale(float x, float y, float z)
{
	return Matrix33(   x, 0.0f, 0.0f,
					0.0f,    y, 0.0f,
					0.0f, 0.0f,    z);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::Rotate(float x, float y, float z, float angle)
{
	return Rotate(Vector3(x, y, z), angle);
}


/***************************************************************************************/
/***************************************************************************************/
Matrix33 Matrix33::Rotate(Vector3 axis, float angle)
{
	axis.NormalizeThis();
	float& x = axis.x;
	float& y = axis.y;
	float& z = axis.z;

	float cos = cosf(angle);
	float sin = sinf(angle);

	Matrix33 uCross( 0.0f,    z,   -y,
					   -z, 0.0f,    x,
					    y,   -x, 0.0f );
	Matrix33 uTensor( x*x, x*y, x*z,
					  y*x, y*y, y*z,
					  z*x, z*y, z*z );

	return (cos * Identity()) + (sin * uCross) + ((1 - cos) * uTensor);
}